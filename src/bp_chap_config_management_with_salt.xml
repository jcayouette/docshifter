<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
                 type="text/xml" 
                 title="Profiling step"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="bp.chapt.config.management.with.salt">
    <title>Configuration Management with Salt</title>

    <sect1 xml:id="bp.chapt.config.mgr.overview">
        <title>Configuration Management Overview</title>
        <para>Salt is capable of applying states by matching minions with relevant state data. This
            data comes from &susemgr; in the form of package and custom states.</para>
    </sect1>
    <sect1 xml:id="bp.chapt.config.mgr.level.hierarchy">
        <title>State Data: Levels of Hierarchy</title>
        <para>State data comes from &susemgr; in the form of package and custom states and targets
            minions at three specific levels of hierarchy. The state hierarchy is defined by the
            following order or priority: Individual minions have priority on packages and custom
            states over groups. Next a group has priority over the organization.</para>
        <itemizedlist>
            <listitem>
             <para>Minion Level</para>
             <itemizedlist>
                        <listitem>
                            <para><menuchoice>
                                    <guimenu>Systems</guimenu>
                                    <guimenu>Specific Minion</guimenu>
                                    <guimenu>States</guimenu>
                                </menuchoice></para>
                        </listitem>
                    </itemizedlist>
            </listitem>
            <listitem>
             <para>Group Level</para>
             <itemizedlist>
                        <listitem>
                            <para><menuchoice>
                                    <guimenu>Systems</guimenu>
                                    <guimenu>System Groups</guimenu>
                                </menuchoice></para>
                        </listitem>
                    </itemizedlist>
            </listitem>
            <listitem>
             <para>Organization Level</para>
             <itemizedlist>
                        <listitem>
                            <para><menuchoice>
                                    <guimenu>Systems</guimenu>
                                    <guimenu>Manage System Types:</guimenu>
                                    <guimenu>My Organization</guimenu>
                                </menuchoice></para>
                        </listitem>
                    </itemizedlist>
            </listitem>
        </itemizedlist>
        <para>For example:</para>
        <itemizedlist>
            <listitem>
                <para>Org1 requires that vim version 1 is installed</para>
            </listitem>
            <listitem>
                <para>Group1 requires that vim version 2 is installed</para>
            </listitem>
            <listitem>
                <para>Group2 requires any version installed</para>
            </listitem>
        </itemizedlist>

        <para>This would lead to the following order of hierarchy:</para>
        <itemizedlist>
            <listitem>
                <para>Minion1 part of [Org1, Group1] wants vim removed, vim is removed (Minion
                    Level)</para>
            </listitem>
            <listitem>
                <para>Minion2 part of [Org1, Group1] wants vim version 2 gets version 2 (Group
                    Level)</para>
            </listitem>
            <listitem>
                <para>Minion3 part of [Org1, Group1] wants any version, gets version 2 (Org
                    Level)</para>
            </listitem>
            <listitem>
                <para>Minion4 part of[Org1, Group2] wants any version, gets vim version 1 (Org
                    Level)</para>
            </listitem>
        </itemizedlist>
    </sect1>

    <sect1 xml:id="bp.chapt.config.mgr.salt.states.storage.locations">
        <title>Salt States Storage Locations</title>
        <para>The &susemgr; salt-master reads its state data from three file root locations.</para>
        <para>The directory <filename>/usr/share/susemanager/salt</filename> is used by
            &susemgr; and comes from the susemanager-sls. It is shipped and updated together with
            &susemgr; and includes certificate setup and common state logic to be applied to
            packages and channels.</para>

        <para>The directory <filename>/srv/susemanager/salt</filename> is generated by
            &susemgr; and based on assigned channels and packages for minions, groups and
            organizations. This file will be overwritten and regenerated. This could be thought of
            as the &susemgr; database translated into salt directives.</para>

        <para>The third directory <filename>/srv/salt</filename> is for custom state data,
            modules etc. &susemgr; does not operate within or utilize this directory. However the
            state data placed here affects the Highstate of minions and is merged with the total
            state result generated by &susemgr;. </para>

    </sect1>
    <sect1 xml:id="bp.chapt.config.mgr.susemgr.states">
        <title>&susemgr; States</title>
        <para>All sls files created by users will be saved to disk on the salt-master server. These
            files will be placed in <filename>/srv/susemanager/salt/</filename> and each
            organization will be placed within its own directory. Although these states are custom,
            these states are created using &susemgr;. The following provides an overview of
            directory structure:</para>
            <screen>├── manager_org_DEVEL
│   ├── files
│   │    ... files needed by states (uploaded by users)...
│   └── state.sls
         ... other sls files (created by users)...
E.g.:
├── manager_org_TESTING
│   ├── files
│   │   └── motd     # user created
│   │    ... other files needed by states ...
│   └── motd.sls     # user created
            ... other sls files ...</screen>
    </sect1>

    <sect1 xml:id="bp.chapt.config.mgr.pillar.data.exposed.susemgr">
        <title>Pillar Data Exposed by &susemgr;</title>
        <para>SUSE Manager exposes a small amount of internal data like group membership,
            organization membership and file roots as pillars which can be used with custom sls
            states. These are managed by &susemgr; or by the user.</para>

        <para>To avoid hard-coding organization id's within sls files, a pillar entry is added for
        each organization:</para>
        <screen>org-files-dir: relative_path_to_files</screen>
        <para>This file will
            be available for all minions which belong to this organization.</para>

        <para>The following represents a Pillar example located in
            <filename>/etc/motd</filename>:</para>
<screen>file.managed:
    - source: salt://{{ pillar['org-files-dir']}}/motd
    - user: root
    - group: root
    - mode: 644
</screen>
        
<!--  
        <sect2 xml:id="bp.chapt.config.mgr.target.org.group.custom.states.using.pillars">
            <title>Targeting Organizations and Groups with Custom States Using Pillars</title>
            <para/>
        </sect2> -->

    </sect1>

</chapter>
